# B+树与最左前缀匹配原则详解

## 目录
1. [什么是数据库索引](#第一步什么是数据库索引)
2. [B+树是什么](#第二步b树是什么)
3. [联合索引是什么](#第三步联合索引是什么)
4. [最左前缀匹配原则](#第四步最左前缀匹配原则)
5. [B+树查找路径演示](#第五步b树查找路径演示)
6. [实际应用建议和最佳实践](#第六步实际应用建议和最佳实践)

---

## 第一步：什么是数据库索引？

索引就像书的目录，能快速定位数据。

### 没有索引的情况
- 查找数据需要逐行扫描（全表扫描）
- 数据量大时很慢

### 有索引的情况
- 通过索引快速定位到数据位置
- 大幅提升查询速度

### 索引的代价
- 占用额外存储空间
- 插入/更新数据时需要维护索引

### 类比
- **没有索引** = 在字典里逐页找字
- **有索引** = 用拼音/部首目录快速定位

---

## 第二步：B+树是什么？

B+树是数据库中最常用的索引数据结构。它像一棵倒置的树，从上到下分为：
- **根节点**（最顶层）
- **中间节点**（中间层）
- **叶子节点**（最底层，存储实际数据）

### B+树的四个核心特点

#### 特点1：非叶子节点只存关键字，不存数据

**文字说明：**
- 非叶子节点包含 M 个关键字（不包含数据）
- 关键字从小到大排列：K[1] < K[2] < ... < K[M]

**结合图中的例子：**
看图中的根节点和中间节点：
- 根节点：`[5, 30, 80]` — 只有数字（关键字），没有"Data"
- 中间节点：`[5, 15, 26]`、`[30, 55, 68]`、`[80, 93, 96]` — 也只有数字，没有"Data"

**为什么这样设计？**
- 非叶子节点只用于导航，不存实际数据
- 节点可以更小，一次能加载更多节点，减少磁盘IO

---

#### 特点2：非叶子节点的指针规则

**文字说明：**
- 非叶子节点有 M 个指针：P[1], P[2], ..., P[M]
- P[i] 指向关键字范围在 `[K[i], K[i+1])` 的子树
- P[M] 指向关键字 ≥ K[M] 的子树

**结合图中的例子：**
看根节点 `[5, 30, 80]` 的三个指针：
- **P1**（对应关键字5）：指向 `[5, 15, 26]` 这个子树
  - 该子树下的所有叶子节点：`[5,8,10]`, `[15,20,25]`, `[26,28,29]`
  - 这些关键字都在 `[5, 30)` 范围内 ✓
- **P2**（对应关键字30）：指向 `[30, 55, 68]` 这个子树
  - 该子树下的叶子节点：`[30,45,53]`, `[55,62,65]`, `[68,70,75]`
  - 这些关键字都在 `[30, 80)` 范围内 ✓
- **P3**（对应关键字80）：指向 `[80, 93, 96]` 这个子树
  - 该子树下的叶子节点：`[80,82,90]`, `[93,94,95]`, `[96,98,99]`
  - 这些关键字都 ≥ 80 ✓

**查找过程示例：**
查找关键字 45：
1. 根节点：45 在 30 和 80 之间 → 走 P2
2. 中间节点 `[30, 55, 68]`：45 在 30 和 55 之间 → 走 P1
3. 到达叶子节点 `[30, 45, 53]`，找到 45

---

#### 特点3：数据只存在叶子节点

**文字说明：**
- 叶子节点包含 M 个关键字和对应的数据
- 所有数据均仅在叶子节点

**结合图中的例子：**
看最底层的叶子节点：
- `[5, 8, 10]` 下面有 "Data Data Data"
- `[15, 20, 25]` 下面有 "Data Data Data"
- 所有叶子节点都有 "Data"

而上面的非叶子节点（根节点和中间节点）都没有 "Data"

**为什么这样设计？**
- 数据统一在叶子节点，查找路径长度一致
- 非叶子节点更小，能容纳更多关键字，树更矮，查找更快

---

#### 特点4：叶子节点形成链表

**文字说明：**
- 叶子节点还包含指向下一个叶子节点的指针

**结合图中的例子：**
看最底层，所有叶子节点从左到右用箭头连接：
```
[5,8,10] → [15,20,25] → [26,28,29] → [30,45,53] → ... → [96,98,99]
```

**为什么这样设计？**
- 范围查询更高效：找到起始叶子节点后，可以沿着链表顺序读取
- 例如查询 "20 到 70 之间的所有数据"：
  1. 从根节点找到包含 20 的叶子节点
  2. 沿着链表向右遍历，直到超过 70

---

### 总结一下B+树的特点：
- **非叶子节点**：只存关键字，用于导航
- **指针规则**：每个指针指向特定范围的子树
- **叶子节点**：存实际数据
- **叶子链表**：支持高效的范围查询

---

## 第三步：联合索引是什么？

### 单列索引 vs 联合索引

**单列索引（之前看到的）：**
- 只按一个字段排序
- 例如：按年龄排序的索引
- B+树中的关键字就是单个值：`5, 8, 10, 15, 20...`

**联合索引（复合索引）：**
- 按多个字段组合排序
- 例如：`(a, b, c)` 表示先按 a 排序，a 相同时按 b 排序，b 相同时按 c 排序

### 联合索引的排序规则（字典序）

联合索引 `(a, b, c)` 的排序规则类似字典：
1. 先比较 a
2. a 相同时比较 b
3. b 相同时比较 c

**例子：**
假设有联合索引 `(a, b, c)`，数据如下：

| a | b | c |
|---|---|---|
| 1 | 1 | 1 |
| 1 | 1 | 6 |
| 1 | 6 | 4 |
| 2 | 2 | 2 |
| 2 | 3 | 1 |
| 3 | 1 | 4 |

在 B+ 树中的排序顺序：
1. `(1, 1, 1)` — a=1 最小
2. `(1, 1, 6)` — a=1，b=1，c=6
3. `(1, 6, 4)` — a=1，b=6
4. `(2, 2, 2)` — a=2
5. `(2, 3, 1)` — a=2，b=3
6. `(3, 1, 4)` — a=3

**关键理解：**
- 排序时，a 的优先级最高，b 次之，c 最低
- 只有 a 相同时，b 才起作用
- 只有 a、b 都相同时，c 才起作用

### 联合索引在 B+ 树中的存储

看你的截图中的节点示例：

```
关键字区域：
a=1, b=1, c=1    ← 这是一个完整的索引值
a=2, b=2, c=2
a=3, b=1, c=4
```

每个节点存储的是 `(a, b, c)` 的组合值，而不是单独的值。

### 联合索引的等价性

创建联合索引 `(a, b, c)` 相当于同时创建了：
- 索引 `(a)` — 可以单独用 a 查询
- 索引 `(a, b)` — 可以用 a 和 b 查询
- 索引 `(a, b, c)` — 可以用 a、b、c 查询

但不能单独用 `(b)` 或 `(c)` 或 `(b, c)` 查询，因为排序时 a 的优先级最高。

---

**关键理解点：**
联合索引的排序是"字典序"，最左边的字段优先级最高。这是理解"最左前缀匹配原则"的基础。

---

## 第四步：最左前缀匹配原则

### 什么是"最左前缀匹配原则"？

**定义：**
使用联合索引查询时，只有在查询条件中使用了索引的最左前缀列，才能使用该索引进行查询。

**简单理解：**
- 联合索引 `(a, b, c)` 是按 `a → b → c` 的顺序排序的
- 只有从最左边的 `a` 开始使用，索引才能生效
- 不能跳过 `a` 直接使用 `b` 或 `c`

### 为什么需要这个原则？

**核心原因：B+树的排序特性**

看你的截图中的说明：
> "因为联合索引中，靠左的索引在B+树排序中靠前。例如有一个联合索引 (a, b, c)，比较两个索引值(a1, b1, c1) 和(a2, b2, c2)，先比较a1 和a2，若a1和a2相等再比较b1 和b2，若b1 和b2相等再比较c1 和c2。"

**形象比喻：**
就像查字典：
- 先看首字母（a）
- 首字母相同再看第二个字母（b）
- 前两个都相同再看第三个字母（c）

如果不知道首字母，就无法快速定位。

### 具体查询例子分析

假设有联合索引 `(a, b, c)`，数据如下：

| a | b | c |
|---|---|---|
| 1 | 1 | 1 |
| 1 | 1 | 6 |
| 1 | 6 | 4 |
| 2 | 2 | 2 |
| 2 | 3 | 1 |
| 3 | 1 | 4 |

#### 例子1：`WHERE a = 2` ✓ 可以使用索引

**为什么可以？**
- 使用了最左边的 `a`
- B+树中，所有 `a=2` 的数据是连续存储的
- 可以快速定位到 `a=2` 的范围

**查找过程：**
1. 从根节点开始，找到 `a=2` 的范围
2. 沿着指针找到包含 `a=2` 的叶子节点
3. 找到所有 `(2, x, x)` 的数据

---

#### 例子2：`WHERE a = 2 AND b = 3` ✓ 可以使用索引

**为什么可以？**
- 使用了最左前缀 `(a, b)`
- 先定位 `a=2`，再在 `a=2` 的范围内找 `b=3`

**查找过程：**
1. 先找到 `a=2` 的范围
2. 在 `a=2` 的数据中，找到 `b=3` 的数据
3. 找到 `(2, 3, 1)`

---

#### 例子3：`WHERE b = 2` ✗ 不能使用索引

**为什么不行？**
- 没有使用最左边的 `a`
- B+树中，`b=2` 的数据不是连续存储的
  - `(1, 6, 4)` 中 b=6
  - `(2, 2, 2)` 中 b=2
  - `(2, 3, 1)` 中 b=3
- 无法利用索引快速定位，只能全表扫描

**查找过程：**
- 必须扫描所有数据，检查每条记录的 `b` 值是否等于 2

---

#### 例子4：`WHERE a = 2 AND b = 2 AND c > 3` ✓ 可以使用索引

**为什么可以？**
- 使用了最左前缀 `(a, b)`
- `c > 3` 是范围查询，在找到 `(a=2, b=2)` 后，可以继续用索引过滤 `c`

**查找过程：**
1. 定位到 `a=2 AND b=2` 的数据
2. 在该范围内，找到 `c > 3` 的数据

---

#### 例子5：`WHERE a > 1 AND b = 1 AND c = 2` ⚠️ 部分使用索引

**为什么只能部分使用？**
- `a > 1` 是范围查询
- 一旦遇到范围查询，后续字段无法直接利用索引进行精确匹配
- 只能使用索引的 `(a)` 部分，不能使用 `(a, b, c)`

**查找过程：**
1. 使用索引找到 `a > 1` 的所有数据（`a=2` 和 `a=3`）
2. 然后在这些数据中，手动检查 `b=1 AND c=2`
3. 无法直接通过索引定位 `(a>1, b=1, c=2)`

**关键理解：**
- 范围查询（`>`, `<`, `BETWEEN` 等）会"切断"索引的使用
- 范围查询之后的字段无法直接利用索引

---

### 总结规则

对于联合索引 `(a, b, c)`：

| 查询条件 | 是否能用索引 | 使用的索引部分 |
|---------|------------|--------------|
| `WHERE a = 2` | ✓ | `(a)` |
| `WHERE a = 2 AND b = 3` | ✓ | `(a, b)` |
| `WHERE a = 2 AND b = 3 AND c = 1` | ✓ | `(a, b, c)` |
| `WHERE b = 2` | ✗ | 无 |
| `WHERE b = 2 AND c = 1` | ✗ | 无 |
| `WHERE a = 2 AND c = 1` | ⚠️ | `(a)` 部分 |
| `WHERE a > 1 AND b = 1` | ⚠️ | `(a)` 部分 |

---

**关键记忆点：**
1. 必须从最左边的字段开始
2. 不能跳过左边的字段
3. 范围查询会限制后续字段的索引使用

---

## 第五步：B+树查找路径演示

### 准确的B+树结构

根据截图，B+树结构如下：

**根节点：**
```
关键字: (1,1,1)  (2,2,2)  (3,1,4)
指针:   P1       P2       P3
```

**叶子节点（从左到右）：**

**左叶子节点（P1指向）：**
- `(1,1,1)` → Data
- `(1,1,6)` → Data
- `(2,1,4)` → Data
- P指针 → 指向中间叶子节点

**中间叶子节点（P2指向）：**
- `(2,2,2)` → Data
- `(2,2,4)` → Data
- `(2,3,1)` → Data
- P指针 → 指向右叶子节点

**右叶子节点（P3指向）：**
- `(3,1,4)` → Data
- `(3,4,1)` → Data
- `(3,5,2)` → Data

---

### 例子1：`WHERE a = 2 AND b = 2` ✓ 可以使用索引

**查询目标：** 找到所有 `a=2` 且 `b=2` 的记录

**查找路径（详细步骤）：**

#### 步骤1：从根节点开始

```
根节点: [(1,1,1) P1]  [(2,2,2) P2]  [(3,1,4) P3]
```

查找 `(2, 2, ?)`：
1. 比较 `(2,2,?)` 与 `(1,1,1)`：
   - 先比较 a：`2 > 1` → 继续向右
2. 比较 `(2,2,?)` 与 `(2,2,2)`：
   - 先比较 a：`2 == 2` ✓
   - 再比较 b：`2 == 2` ✓
   - 再比较 c：`? <= 2`（目标c未知，但a和b已匹配）
   - 结论：目标在 P2 指向的子树中

**决策：** 沿着 P2 指针向下

---

#### 步骤2：到达中间叶子节点

到达 P2 指向的中间叶子节点：
```
中间叶子节点: (2,2,2)  (2,2,4)  (2,3,1)
```

顺序扫描：
1. `(2,2,2)`：
   - a=2 ✓，b=2 ✓ → 匹配，返回这条记录
2. `(2,2,4)`：
   - a=2 ✓，b=2 ✓ → 匹配，返回这条记录
3. `(2,3,1)`：
   - a=2 ✓，b=3 ✗（b=3 > 2）
   - 由于叶子节点有序，后续不会有 b=2 的记录
   - 停止扫描

**结果：** 找到 `(2,2,2)` 和 `(2,2,4)` 两条记录

---

### 例子2：`WHERE a = 2` ✓ 可以使用索引

**查询目标：** 找到所有 `a=2` 的记录（不管 b 和 c 是多少）

**查找路径：**

#### 步骤1：从根节点开始

```
根节点: [(1,1,1) P1]  [(2,2,2) P2]  [(3,1,4) P3]
```

查找 `(2, ?, ?)`：
1. 比较 `(2,?,?)` 与 `(1,1,1)`：
   - 先比较 a：`2 > 1` → 继续向右
2. 比较 `(2,?,?)` 与 `(2,2,2)`：
   - 先比较 a：`2 == 2` ✓
   - 结论：目标在 P2 指向的子树中

**决策：** 沿着 P2 指针向下

---

#### 步骤2：扫描中间叶子节点

```
中间叶子节点: (2,2,2)  (2,2,4)  (2,3,1)
```

顺序扫描：
1. `(2,2,2)`：a=2 ✓ → 匹配
2. `(2,2,4)`：a=2 ✓ → 匹配
3. `(2,3,1)`：a=2 ✓ → 匹配
4. 由于这是 P2 指向的最后一个节点，且下一个节点（P3指向）的 a=3，所以停止

**结果：** 找到 `(2,2,2)`、`(2,2,4)`、`(2,3,1)` 三条记录

---

### 例子3：`WHERE b = 2` ✗ 不能使用索引

**查询目标：** 找到所有 `b=2` 的记录（不管 a 是多少）

**查找路径（为什么失败）：**

#### 步骤1：在根节点遇到问题

```
根节点: [(1,1,1) P1]  [(2,2,2) P2]  [(3,1,4) P3]
```

查找 `(?, 2, ?)`：
- 根节点的关键字是 `(a, b, c)` 的组合
- 不知道 a 的值，无法判断：
  - `b=2` 可能在 P1 子树（a=1，但该子树中 b 可能是 1 或 6）
  - `b=2` 可能在 P2 子树（a=2，该子树中确实有 b=2）
  - `b=2` 可能在 P3 子树（a=3，但该子树中 b 可能是 1 或 4）
- 无法选择走哪个指针

**结论：** 无法利用索引快速定位，必须扫描所有叶子节点

---

#### 步骤2：被迫全表扫描

必须检查所有叶子节点：
1. 左叶子节点：`(1,1,1)`, `(1,1,6)`, `(2,1,4)` → 没有 b=2
2. 中间叶子节点：`(2,2,2)`, `(2,2,4)`, `(2,3,1)` → 有 b=2（前两条）
3. 右叶子节点：`(3,1,4)`, `(3,4,1)`, `(3,5,2)` → 没有 b=2

**结果：** 虽然能找到数据，但效率低（全表扫描）

---

### 例子4：`WHERE a = 2 AND b = 2 AND c > 3` ✓ 可以使用索引

**查询目标：** 找到所有 `a=2` 且 `b=2` 且 `c > 3` 的记录

**查找路径：**

#### 步骤1：从根节点开始（同例子1）

找到 P2 指向的中间叶子节点

#### 步骤2：扫描中间叶子节点

```
中间叶子节点: (2,2,2)  (2,2,4)  (2,3,1)
```

顺序扫描：
1. `(2,2,2)`：
   - a=2 ✓，b=2 ✓，c=2 ✗（c=2 不大于 3）
   - 不匹配
2. `(2,2,4)`：
   - a=2 ✓，b=2 ✓，c=4 ✓（c=4 > 3）
   - 匹配！
3. `(2,3,1)`：
   - a=2 ✓，b=3 ✗
   - 停止扫描

**结果：** 找到 `(2,2,4)` 一条记录

---

### 例子5：`WHERE a > 1 AND b = 1 AND c = 2` ⚠️ 部分使用索引

**查询目标：** 找到所有 `a > 1` 且 `b=1` 且 `c=2` 的记录

**查找路径：**

#### 步骤1：从根节点开始

```
根节点: [(1,1,1) P1]  [(2,2,2) P2]  [(3,1,4) P3]
```

查找 `(a>1, 1, 2)`：
- `a > 1` 意味着 a 可以是 2 或 3
- 需要检查 P2（a=2）和 P3（a=3）指向的子树

**决策：** 需要扫描 P2 和 P3 指向的叶子节点

---

#### 步骤2：扫描中间叶子节点（P2）

```
中间叶子节点: (2,2,2)  (2,2,4)  (2,3,1)
```

检查每条记录：
- `(2,2,2)`：a=2 ✓（>1），b=2 ✗（需要 b=1）
- `(2,2,4)`：a=2 ✓，b=2 ✗
- `(2,3,1)`：a=2 ✓，b=3 ✗
- 没有匹配的记录

---

#### 步骤3：扫描右叶子节点（P3）

```
右叶子节点: (3,1,4)  (3,4,1)  (3,5,2)
```

检查每条记录：
- `(3,1,4)`：a=3 ✓（>1），b=1 ✓，c=4 ✗（需要 c=2）
- `(3,4,1)`：a=3 ✓，b=4 ✗
- `(3,5,2)`：a=3 ✓，b=5 ✗
- 没有匹配的记录

**结果：** 没有找到匹配的记录

---

### 为什么例子5只能部分使用索引？

**关键原因：**
- `a > 1` 是范围查询，一旦遇到范围查询，后续字段无法直接利用索引进行精确匹配
- 只能使用索引的 `(a)` 部分来定位 `a > 1` 的范围
- 然后在这些范围内，手动检查 `b=1` 和 `c=2`
- 无法直接通过索引定位 `(a>1, b=1, c=2)`

**对比：**
- 如果查询是 `WHERE a = 3 AND b = 1 AND c = 4`：
  - 可以直接定位到 P3 → 右叶子节点 → `(3,1,4)`
  - 效率更高

---

### 总结

基于准确的B+树结构，查找路径如下：

| 查询条件 | 查找路径 | 效率 |
|---------|---------|------|
| `WHERE a = 2 AND b = 2` | 根节点 → P2 → 中间叶子节点（扫描部分） | 高 ✓ |
| `WHERE a = 2` | 根节点 → P2 → 中间叶子节点（扫描全部） | 高 ✓ |
| `WHERE b = 2` | 必须扫描所有叶子节点 | 低 ✗ |
| `WHERE a = 2 AND b = 2 AND c > 3` | 根节点 → P2 → 中间叶子节点（扫描部分） | 高 ✓ |
| `WHERE a > 1 AND b = 1 AND c = 2` | 根节点 → P2和P3 → 扫描两个叶子节点 | 中 ⚠️ |

---

## 第六步：实际应用建议和最佳实践

### 1. 联合索引字段顺序的选择原则

**核心原则：** 把最常用的、选择性高的字段放在最左边

#### 选择性（Cardinality）
- **选择性高**：字段的值分布广泛，重复值少
- **选择性低**：字段的值重复多

**例子：**
假设有一个用户表，有字段：
- `user_id`（主键，选择性极高）
- `status`（状态：0/1，选择性低）
- `create_time`（创建时间，选择性高）

**错误的索引：**
```sql
CREATE INDEX idx_status_time ON users(status, create_time);
```
- `status` 选择性低，放在最左边浪费了索引的优势

**正确的索引：**
```sql
CREATE INDEX idx_time_status ON users(create_time, status);
```
- `create_time` 选择性高，放在最左边能快速缩小范围
- `status` 放在后面，在时间范围内进一步过滤

---

### 2. 常见查询模式的索引设计

#### 场景1：多条件查询
**查询：** `WHERE a = ? AND b = ? AND c = ?`
**索引：** `(a, b, c)` ✓

#### 场景2：范围查询 + 等值查询
**查询：** `WHERE a = ? AND b > ? AND c = ?`
**索引：** `(a, b, c)` ✓
- 注意：`b > ?` 是范围查询，`c = ?` 只能部分利用索引

#### 场景3：只查最左字段
**查询：** `WHERE a = ?`
**索引：** `(a, b, c)` ✓
- 可以使用索引的 `(a)` 部分

#### 场景4：跳过最左字段
**查询：** `WHERE b = ? AND c = ?`
**索引：** `(a, b, c)` ✗
- 无法使用索引，需要创建 `(b, c)` 索引

---

### 3. 索引设计的"最左前缀"原则应用

#### 原则1：最常用的字段放最左
```sql
-- 如果经常查询 WHERE user_id = ? AND status = ?
CREATE INDEX idx_user_status ON orders(user_id, status);
```

#### 原则2：等值查询字段优先于范围查询字段
```sql
-- 如果查询 WHERE user_id = ? AND create_time > ?
CREATE INDEX idx_user_time ON orders(user_id, create_time);
-- 而不是 (create_time, user_id)
```

#### 原则3：考虑查询的覆盖性
```sql
-- 如果查询只需要返回 user_id 和 status
CREATE INDEX idx_user_status ON orders(user_id, status);
-- 这样索引可以"覆盖"查询，不需要回表
```

---

### 4. 避免常见的索引设计错误

#### 错误1：字段顺序不合理
```sql
-- ❌ 错误：把选择性低的字段放最左
CREATE INDEX idx_status_user ON orders(status, user_id);

-- ✅ 正确：把选择性高的字段放最左
CREATE INDEX idx_user_status ON orders(user_id, status);
```

#### 错误2：创建冗余索引
```sql
-- ❌ 错误：如果已有 (a, b, c)，不需要再创建 (a, b)
CREATE INDEX idx_a_b_c ON table1(a, b, c);
CREATE INDEX idx_a_b ON table1(a, b);  -- 冗余！

-- ✅ 正确：只创建 (a, b, c) 即可
CREATE INDEX idx_a_b_c ON table1(a, b, c);
```

#### 错误3：忽略最左前缀原则
```sql
-- ❌ 错误：查询 WHERE b = ? 无法使用 (a, b, c) 索引
-- 需要创建单独的 (b) 索引或 (b, c) 索引
```

---

### 5. 实际案例分析

#### 案例1：电商订单表
**表结构：**
```sql
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    user_id INT,
    status TINYINT,
    create_time DATETIME,
    amount DECIMAL(10,2)
);
```

**常见查询：**
1. `WHERE user_id = ? AND status = ?` （用户查看自己的订单）
2. `WHERE user_id = ? AND create_time > ?` （用户查看最近订单）
3. `WHERE status = ? AND create_time > ?` （管理员查看待处理订单）

**索引设计：**
```sql
-- 索引1：覆盖查询1和2
CREATE INDEX idx_user_status ON orders(user_id, status);
CREATE INDEX idx_user_time ON orders(user_id, create_time);

-- 索引2：覆盖查询3（注意：这个查询无法完全利用索引）
CREATE INDEX idx_status_time ON orders(status, create_time);
-- 但 WHERE status = ? 可以使用索引
```

---

#### 案例2：文章表
**表结构：**
```sql
CREATE TABLE articles (
    article_id INT PRIMARY KEY,
    author_id INT,
    category_id INT,
    publish_time DATETIME,
    status TINYINT
);
```

**常见查询：**
1. `WHERE author_id = ? AND status = ?` （作者查看自己的文章）
2. `WHERE category_id = ? AND publish_time > ?` （分类下最新文章）
3. `WHERE status = ? ORDER BY publish_time DESC` （最新发布的文章）

**索引设计：**
```sql
-- 索引1：覆盖查询1
CREATE INDEX idx_author_status ON articles(author_id, status);

-- 索引2：覆盖查询2
CREATE INDEX idx_category_time ON articles(category_id, publish_time);

-- 索引3：覆盖查询3（注意：ORDER BY 可以利用索引排序）
CREATE INDEX idx_status_time ON articles(status, publish_time);
```

---

### 6. 索引使用检查技巧

#### 使用 EXPLAIN 查看执行计划
```sql
EXPLAIN SELECT * FROM orders WHERE user_id = 1 AND status = 1;
```

**关键字段：**
- `key`：使用的索引名称
- `key_len`：使用的索引长度（可以判断使用了索引的哪些字段）
- `rows`：扫描的行数（越少越好）
- `type`：访问类型（`ref`、`range` 表示使用了索引）

#### 判断索引是否生效
```sql
-- 如果 key_len = 4（假设 user_id 是 INT），说明只用了 user_id
-- 如果 key_len = 5（假设 status 是 TINYINT），说明用了 user_id + status
```

---

### 7. 最佳实践总结

1. **字段顺序**：最常用、选择性高的字段放最左
2. **等值优先**：等值查询字段优先于范围查询字段
3. **避免冗余**：利用最左前缀原则，避免创建冗余索引
4. **覆盖索引**：如果查询只需要索引字段，考虑创建覆盖索引
5. **定期检查**：使用 EXPLAIN 检查索引使用情况
6. **权衡利弊**：索引不是越多越好，要考虑写入性能

---

## 总结

### 核心概念回顾

1. **B+树**：数据库索引的底层数据结构，具有有序性、多路分支、数据在叶子节点等特点
2. **联合索引**：多个字段组合的索引，按字典序排序
3. **最左前缀匹配原则**：只有使用索引最左边的字段，才能利用索引快速查找
4. **范围查询限制**：范围查询会"切断"后续字段的索引使用

### 关键记忆点

- ✅ 必须从最左边的字段开始
- ✅ 不能跳过左边的字段
- ✅ 范围查询会限制后续字段的索引使用
- ✅ 最常用的字段放在最左边
- ✅ 等值查询优先于范围查询

---

**希望这份文档能帮助你深入理解B+树和最左前缀匹配原则！**
